"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergePdf = mergePdf;
const transport_1 = require("../../../transport");
async function mergePdf(index) {
    const rawUrls = this.getNodeParameter('url', index);
    let inputUrls;
    if (Array.isArray(rawUrls)) {
        inputUrls = rawUrls;
    }
    else if (typeof rawUrls === 'string') {
        inputUrls = rawUrls.includes(',') ? rawUrls.split(',') : [rawUrls];
    }
    else {
        inputUrls = [];
    }
    inputUrls = inputUrls.map((url) => url.trim()).filter((url) => url.length > 0);
    const autoConvert = this.getNodeParameter('autoConvert', index);
    const advancedOptions = this.getNodeParameter('advancedOptions', index);
    const fileName = advancedOptions === null || advancedOptions === void 0 ? void 0 : advancedOptions.name;
    const profiles = advancedOptions === null || advancedOptions === void 0 ? void 0 : advancedOptions.profiles;
    const callback = advancedOptions === null || advancedOptions === void 0 ? void 0 : advancedOptions.callback;
    const endpoint = autoConvert ? `/v1/pdf/merge2` : `/v1/pdf/merge`;
    const inputUrl = inputUrls.join(',');
    const body = { url: inputUrl, async: true };
    if (fileName)
        body.name = fileName;
    if (callback)
        body.callback = callback;
    if (profiles)
        body.profiles = profiles;
    (0, transport_1.sanitizeProfiles)(body);
    const responseData = await transport_1.pdfcoApiRequestWithJobCheck.call(this, endpoint, body);
    return this.helpers.returnJsonArray(responseData);
}
//# sourceMappingURL=execute.js.map